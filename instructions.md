Project Engagement Tasks: We will be updating the specification to include some more information soon, but for now here is some information about engagement tasks relating to the project. NOTE: Each of these must be submitted to the private engagement task forum that you are able to post to; they will not be assessed if they are only submitted to the main project submission:
0.5% X 2: Early Start + Planning: Get an early start. You can achieve this either by providing a solid plan of your approach for the project OR by getting a good start on the work for the project. This task must be submitted by 23:59 on Monday, November 17th. It will not be counted after this time. You may submit this twice for up to 1% total by completing two different tasks. Submit evidence of at least ONE of the following:
Plan: Provide detailed flowcharts, pseudocode, or step-by-step algorithms for the major pieces of functionality. They must be more detailed than what has been provided to you in the overview video and written in your own words. They should be sufficient to closely guide your work.
Tasklist: Write yourself a clear and detailed tasklist which describes the order that you will write and test your features to implement the project. It should cover the full project and be detailed enough to nearly describe the functions. At minimum 10 tasks in a prioritized order.
Header Interface: Submit a header file that contains detailed function prototypes, structures, and some comments over the function prototypes that lay out the majority of what functionality you expect to need for your project. You should aim to break functions down into smaller parts and, for any non-trivial function, include a comment that briefly describes what it's expectations are.
Early Start: Have enough of the project completed that you can at least have the Ghost walking around the house, leaving evidence, and exiting out of boredom. If the header file contains all of the structures and forward declarations for the rest of the project, you can also get Planning Task #3 for an additional 0.5%.

1% Version Control: Submit evidence that you used version control, such as Git, throughout the project. We will not be discussing git in-class and cannot offer support (some TAs might be able during student hours), but it is an industry-standard tool that is very helpful for future co-op and work experiences. Learning git can be very challenging, so you are only encouraged to do this if you are very interested and possibly have a friend to support your learning of git.
Project Bonus Marks: These bonus marks will apply to the project, up to a maximum grade of 100%, and can be used to make up small amounts of marks that might be lost, though again - the marks will not go above 100%. Note: These will often be more work than the percentage value and are encouraged to reward those interested in doing a little bit more.

Submission: These must be included with your project and MUST be noted in your README file to receive bonus marks. If they are included, but not mentioned in your README file, they will not receive any marks.

1% Documentation: Provide documentation (with the same requirements from assignments) for each of the functions that you implement. You are encouraged to use the "doxygen" style comment format that is shown in the provided helper code.
2% Testing Suite: Include a suite of tests for most of the major pieces of functionality to ensure that you have the correct behaviour as you work. 
2% Improved Behaviour: Implement and describe some kind of more unique behaviour for both regular movement and swapping of devices than pure random selection. Briefly describe this improved method in the README. Note: Selecting the next one from a list is not considered an improvement over random, it must implement some kind of logic.
2% Pathfinding: Implement a toggle, e.g., with a definition or with an input at the beginning of the program, that will switch the "Return to Exit" behaviour from using the room stack to instead using a path determined by a breadth-first search or other pathfinding algorithm. Describe this alternative method and how to activate it in the README file. The standard room stack (breadcrumb) approach must still be implemented and on by default.
3% UI: (Requires full ghost and hunter behaviour to be implemented) Use the ncurses library or shell console codes to create a live-updating (non-scrolling) advanced user interface for visualizing the simulation. You may disable the prints in the logging functions so long as they still log out to the files.
5% Arguments and Multiprocessing:  (Requires full ghost and hunter behaviour to be implemented) Write a second program, to be run as a separate process, which uses fork and exec to run your simulation at least 30 times. When running, it should pass a command line argument to tell it to report its win/lose condition (e.g., --report). When the simulation completes, if the program was executed with the --report (or similar) argument, then it will send a signal to the parent process reporting either that the hunters win (SIGUSR1) or the ghosts win (SIGUSR2). The parent process that is running the simulators then reports the ratio of hunter wins to ghost wins.